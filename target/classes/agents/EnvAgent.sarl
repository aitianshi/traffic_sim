/** 
 * 
 */
package agents

import io.sarl.core.Initialize
import io.sarl.core.Logging
import events.Influence
import io.sarl.core.DefaultContextInteractions
import events.ArrivedAtDestination
import road_elements.Road
import road_elements.TrafficLayers
import road_elements.Car
import org.arakhne.afc.gis.road.primitive.RoadNetwork
import io.sarl.core.Lifecycle
import java.util.UUID
import java.util.TreeMap
import events.ArrivedAtEndRoad
import events.MoveForward
import java.util.concurrent.atomic.AtomicInteger
import org.arakhne.afc.math.geometry.d1.d.Point1d

/** 
 * @author robin
 * 
 */
agent EnvAgent {
	uses Logging
	uses DefaultContextInteractions
	uses Lifecycle

	var network : RoadNetwork
	var trafficLayers : TrafficLayers
	val agentId_Cars = new TreeMap<UUID, Car>
	var nbInfluenceToCompute = new AtomicInteger
	var time = new AtomicInteger

	on Initialize {
		this.nbInfluenceToCompute.set(0)
		this.time.set(0)
		this.trafficLayers = occurrence.parameters.get(0) as TrafficLayers
		this.network = this.trafficLayers.roadNetworkLayer.roadNetwork

		// print(tl.mapElementLayer)

		/* 
		 * var voiture = new Car(0, this.network.roadSegments.get(0) as Road, tl)
		 * var voiture3 = new Car(1000, this.network.roadSegments.get(0) as Road, tl)
		 * var voiture2 = new Car(1, this.network.roadSegments.get(2) as Road, tl)
		 */
		// print(tl.mapElementLayer)
		spawnCarAndAgent
		//spawnCarAndAgent
		/* spawnCarAndAgent
	 * spawnCarAndAgent
	 * spawnCarAndAgent
	 */
		// spawnCarAndAgent
		// emit(new Perception)[elt|elt.UUID==id]
	}

	on Influence {
		var agentId = occurrence.agentId
		var car = this.getCarByAgentId(agentId)
		car.influence = occurrence
		this.nbInfluenceToCompute.incrementAndGet
		if (this.nbInfluenceToCompute >= this.agentId_Cars.size) {
			computeInfluences
		}
	}

	def computeInfluences {
		// info(this.nbInfluenceToCompute)
		Thread::sleep(250)
		for (b : agentId_Cars.entrySet) {
			var body = b.value
			var agentId = body.influence.agentId
			var car = this.getCarByAgentId(agentId)

			if (car.coordinates.equals(body.influence.arrivalPoint)) {
				emit(new ArrivedAtDestination)[elt|elt.UUID == agentId]
				return;
			}

			if (car.coordinates.equals(body.influence.nextPoint)) {
				emit(new ArrivedAtEndRoad)[elt|elt.UUID == agentId]
				return;
			}

			emit(new MoveForward)[elt|elt.UUID == agentId]
		}

		this.nbInfluenceToCompute.set(0)

		// info(this.nbInfluenceToCompute)
		this.time.incrementAndGet

	}

	def removeAgentAndCar(idAgent : UUID) {
		this.agentId_Cars.remove(idAgent)
	}

	synchronized def spawnCarAndAgent(time : int = 0) : UUID {
		while (this.time < 0) {
		}

		var nbRoads = this.network.roadSegments.size
		var indexRoadRandom = (Math.random() * nbRoads) as int
		var selectedRoad = this.network.roadSegments.get(indexRoadRandom) as Road
		info(selectedRoad)
		// A FAIRE : vérifier si rien en dessous, sinon attendre que la place se libère ou chercher une autre place
		var car = new Car(new Point1d(selectedRoad, 0, 1), selectedRoad, this.trafficLayers)
		var id = Driver.spawn(car, this.network, this)
		agentId_Cars.put(id, car)
		return id
	}

	def getCarByAgentId(agentId : UUID) : Car {
		return this.agentId_Cars.get(agentId)
	}
}

